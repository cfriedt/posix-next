From 47aa6c2e5faf31ea94102655cc18517cbde91b98 Mon Sep 17 00:00:00 2001
From: Marco Casaroli <marco.casaroli@gmail.com>
Date: Wed, 12 Nov 2025 09:18:35 +0100
Subject: [PATCH 1/4] tests: eventfd: posix read interface

The eventfd API should work with the standard POSIX read/write
functions with the same behavior as the non-standard
eventfd_read/write API.

We add the tests for these interfaces.

Signed-off-by: Marco Casaroli <marco.casaroli@gmail.com>
---
 lib/os/zvfs/zvfs_eventfd.c | 46 +++++++++++++++++++++++++++-----------
 1 file changed, 33 insertions(+), 13 deletions(-)

diff --git a/lib/os/zvfs/zvfs_eventfd.c b/lib/os/zvfs/zvfs_eventfd.c
index c4c329826db78..deab024e93461 100644
--- a/lib/os/zvfs/zvfs_eventfd.c
+++ b/lib/os/zvfs/zvfs_eventfd.c
@@ -189,9 +189,6 @@ static int zvfs_eventfd_close_op(void *obj)
 	__ASSERT_NO_MSG(lock != NULL);
 	__ASSERT_NO_MSG(cond != NULL);
 
-	err = k_mutex_lock(lock, K_FOREVER);
-	__ASSERT(err == 0, "k_mutex_lock() failed: %d", err);
-
 	key = k_spin_lock(&efd->lock);
 
 	if (!zvfs_eventfd_is_in_use(efd)) {
@@ -213,8 +210,6 @@ static int zvfs_eventfd_close_op(void *obj)
 	/* when closing an zvfs_eventfd, broadcast to all waiters */
 	err = k_condvar_broadcast(cond);
 	__ASSERT(err == 0, "k_condvar_broadcast() failed: %d", err);
-	err = k_mutex_unlock(lock);
-	__ASSERT(err == 0, "k_mutex_unlock() failed: %d", err);
 
 	return ret;
 }
@@ -351,10 +346,7 @@ static ssize_t zvfs_eventfd_rw_op(void *obj, void *buf, size_t sz,
 	__ASSERT_NO_MSG(lock != NULL);
 	__ASSERT_NO_MSG(cond != NULL);
 
-	/* do not hold a spinlock when taking a mutex */
 	k_spin_unlock(&efd->lock, key);
-	err = k_mutex_lock(lock, K_FOREVER);
-	__ASSERT(err == 0, "k_mutex_lock() failed: %d", err);
 
 	while (true) {
 		/* retake the spinlock */
@@ -368,13 +360,13 @@ static ssize_t zvfs_eventfd_rw_op(void *obj, void *buf, size_t sz,
 		case 0:
 			/* success! */
 			ret = sizeof(zvfs_eventfd_t);
-			goto unlock_mutex;
+			goto unlock;
 		default:
 			/* some other error */
 			__ASSERT_NO_MSG(ret < 0);
 			errno = -ret;
 			ret = -1;
-			goto unlock_mutex;
+			goto unlock;
 		}
 
 		/* do not hold a spinlock when taking a mutex */
@@ -385,13 +377,11 @@ static ssize_t zvfs_eventfd_rw_op(void *obj, void *buf, size_t sz,
 		__ASSERT(err == 0, "k_condvar_wait() failed: %d", err);
 	}
 
-unlock_mutex:
+unlock:
 	k_spin_unlock(&efd->lock, key);
 	/* only wake a single waiter */
 	err = k_condvar_signal(cond);
 	__ASSERT(err == 0, "k_condvar_signal() failed: %d", err);
-	err = k_mutex_unlock(lock);
-	__ASSERT(err == 0, "k_mutex_unlock() failed: %d", err);
 	goto out;
 
 unlock_spin:
@@ -450,14 +440,29 @@ int zvfs_eventfd_read(int fd, zvfs_eventfd_t *value)
 {
 	int ret;
 	void *obj;
+	int err;
+	struct k_mutex *lock = NULL;
+	struct k_condvar *cond = NULL;
 
 	obj = zvfs_get_fd_obj(fd, &zvfs_eventfd_fd_vtable, EBADF);
 	if (obj == NULL) {
 		return -1;
 	}
 
+	err = (int)zvfs_get_obj_lock_and_cond(obj, &zvfs_eventfd_fd_vtable, &lock, &cond);
+	__ASSERT((bool)err, "zvfs_get_obj_lock_and_cond() failed");
+	__ASSERT_NO_MSG(lock != NULL);
+	__ASSERT_NO_MSG(cond != NULL);
+
+	err = k_mutex_lock(lock, K_FOREVER);
+	__ASSERT(err == 0, "k_mutex_lock() failed: %d", err);
+
 	ret = zvfs_eventfd_rw_op(obj, value, sizeof(zvfs_eventfd_t), zvfs_eventfd_read_locked);
 	__ASSERT_NO_MSG(ret == -1 || ret == sizeof(zvfs_eventfd_t));
+
+	err = k_mutex_unlock(lock);
+	__ASSERT(err == 0, "k_mutex_unlock() failed: %d", err);
+
 	if (ret < 0) {
 		return -1;
 	}
@@ -469,14 +474,29 @@ int zvfs_eventfd_write(int fd, zvfs_eventfd_t value)
 {
 	int ret;
 	void *obj;
+	int err;
+	struct k_mutex *lock = NULL;
+	struct k_condvar *cond = NULL;
 
 	obj = zvfs_get_fd_obj(fd, &zvfs_eventfd_fd_vtable, EBADF);
 	if (obj == NULL) {
 		return -1;
 	}
 
+	err = (int)zvfs_get_obj_lock_and_cond(obj, &zvfs_eventfd_fd_vtable, &lock, &cond);
+	__ASSERT((bool)err, "zvfs_get_obj_lock_and_cond() failed");
+	__ASSERT_NO_MSG(lock != NULL);
+	__ASSERT_NO_MSG(cond != NULL);
+
+	err = k_mutex_lock(lock, K_FOREVER);
+	__ASSERT(err == 0, "k_mutex_lock() failed: %d", err);
+
 	ret = zvfs_eventfd_rw_op(obj, &value, sizeof(zvfs_eventfd_t), zvfs_eventfd_write_locked);
 	__ASSERT_NO_MSG(ret == -1 || ret == sizeof(zvfs_eventfd_t));
+
+	err = k_mutex_unlock(lock);
+	__ASSERT(err == 0, "k_mutex_unlock() failed: %d", err);
+
 	if (ret < 0) {
 		return -1;
 	}

From 78f1676225972653411ab5b6be7baff3b403ad31 Mon Sep 17 00:00:00 2001
From: Marco Casaroli <marco.casaroli@gmail.com>
Date: Sat, 15 Nov 2025 10:56:49 +0100
Subject: [PATCH 3/4] posix: eventfd: ignore k_condvar_broadcast result

k_condvar_broadcast does not error. It returns the number of
woken threads on success. We should not assert any value.

Signed-off-by: Marco Casaroli <marco.casaroli@gmail.com>
---
 lib/os/zvfs/zvfs_eventfd.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/lib/os/zvfs/zvfs_eventfd.c b/lib/os/zvfs/zvfs_eventfd.c
index deab024e93461..81907f9315a53 100644
--- a/lib/os/zvfs/zvfs_eventfd.c
+++ b/lib/os/zvfs/zvfs_eventfd.c
@@ -208,8 +208,7 @@ static int zvfs_eventfd_close_op(void *obj)
 unlock:
 	k_spin_unlock(&efd->lock, key);
 	/* when closing an zvfs_eventfd, broadcast to all waiters */
-	err = k_condvar_broadcast(cond);
-	__ASSERT(err == 0, "k_condvar_broadcast() failed: %d", err);
+	k_condvar_broadcast(cond);
 
 	return ret;
 }
